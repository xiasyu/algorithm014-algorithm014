<a name="index">**Index**</a>
&emsp;<a href="#0">ç¬¬å››å‘¨</a>  
&emsp;<a href="#1">è´ªå¿ƒç®—æ³•ï¼š</a>  
&emsp;<a href="#2">åŠ¨æ€è§„åˆ’</a>  
&emsp;<a href="#3">è´ªå¿ƒç®—æ³•å’ŒåŠ¨æ€è§„åˆ’</a>  
&emsp;<a href="#4">å›æº¯çš„çŸ¥è¯†ç‚¹ï¼š(è®²çš„å¾ˆå¥½)</a>  
&emsp;<a href="#5">å‰ªæ</a>  
&emsp;<a href="#6">å›¾çš„æœ€çŸ­è·¯å¾„</a>  
&emsp;<a href="#7">DFS ä»£ç é€’å½’å†™æ³•</a>  
&emsp;<a href="#8">DFS ä»£ç éé€’å½’å†™æ³•</a>  
&emsp;<a href="#9">äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ¨¡ç‰ˆ(éé€’å½’)</a>  
&emsp;<a href="#10">äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ¨¡ç‰ˆ(é€’å½’)</a>  
&emsp;<a href="#11">é¢˜å‹äºŒï¼šFlood Fill</a>  
&emsp;<a href="#12">é¢˜å‹ä¸‰ï¼šå­—ç¬¦ä¸²ä¸­çš„å›æº¯é—®é¢˜</a>  
&emsp;<a href="#13">é¢˜å‹å››ï¼šæ¸¸æˆé—®é¢˜</a>  
&emsp;&emsp;&emsp;<a href="#14">ä»£ç </a>  
&emsp;&emsp;&emsp;<a href="#15">102. äºŒå‰æ ‘çš„å±‚åºéå†</a>  
&emsp;&emsp;&emsp;<a href="#16">33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#17"> æœç´¢æ—‹è½¬æ’åºæ•°ç»„çš„æ„Ÿæƒ³</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#18">22. æ‹¬å·ç”Ÿæˆ</a>  
&emsp;&emsp;&emsp;&emsp;&emsp;<a href="#19">å…¨æ’åˆ—æ„Ÿæƒ³</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#20">47. å…¨æ’åˆ— II</a>  
&emsp;&emsp;&emsp;&emsp;&emsp;<a href="#21">å…¨æ’åˆ— IIæ„Ÿæƒ³</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#22">77. ç»„åˆ</a>  
&emsp;&emsp;&emsp;&emsp;&emsp;<a href="#23">ç»„åˆæ„Ÿæƒ³</a>  
&emsp;&emsp;&emsp;&emsp;<a href="#24">560. å’Œä¸ºKçš„å­æ•°ç»„</a>  
## <a name="0">ç¬¬å››å‘¨</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

## <a name="1">è´ªå¿ƒç®—æ³•ï¼š</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
æ¦‚å¿µï¼šè´ªå¿ƒç®—æ³•æ˜¯ä¸€ç§åœ¨æ¯ä¸€æ­¥é€‰æ‹©ä¸­éƒ½é‡‡å–åœ¨å½“å‰çŠ¶æ€ä¸‹æœ€å¥½æˆ–æœ€ä¼˜ï¼ˆå³æœ€æœ‰åˆ©ï¼‰çš„é€‰æ‹©ï¼Œä»è€Œå¸Œæœ›å¯¼è‡´ç»“æœæ˜¯å…¨å±€æœ€å¥½æˆ–æœ€ä¼˜çš„ç»“æœ
## <a name="2">åŠ¨æ€è§„åˆ’</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
æ¦‚å¿µï¼š
## <a name="3">è´ªå¿ƒç®—æ³•å’ŒåŠ¨æ€è§„åˆ’</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
åŒºåˆ«ï¼šè´ªå¿ƒç®—æ³•å¯¹æ¯ä¸ªå­é—®é¢˜çš„è§£å†³æ–¹æ¡ˆéƒ½ä½œå‡ºé€‰æ‹©ï¼Œä¸èƒ½å›é€€ã€‚åŠ¨æ€è§„åˆ’åˆ™ä¼šä¿å¯¸ä»¥å‰çš„ç»“æœï¼Œå¹¶æ ¹æ®ä»¥å‰çš„ç»“æœå¯¹å½“å‰ç»“æœè¿›è¡Œé€‰æ‹©ï¼Œæœ‰å›é€€åŠŸèƒ½ã€‚
## <a name="4">å›æº¯çš„çŸ¥è¯†ç‚¹ï¼š(è®²çš„å¾ˆå¥½)</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
> https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/

 
## <a name="5">å‰ªæ</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

## <a name="6">å›¾çš„æœ€çŸ­è·¯å¾„</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢



## <a name="7">DFS ä»£ç é€’å½’å†™æ³•</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

```
visited = set()
def dfs(self, node:TreeNode ,visited:List()):
    if node is in visited():
        // already visited
        return
        
    visited.append(node.value)
    // process current node here
    ...
    for next_node in node.children():
        if next_mode is not in visited:
            self.dfs(next_node, visited)
```
## <a name="8">DFS ä»£ç éé€’å½’å†™æ³•</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```

```

## <a name="9">äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ¨¡ç‰ˆ(éé€’å½’)</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
def binarySearch(self, nums: List[int], target: int) -> int:
    left,right = 0, n - 1
    while left < right:
           mid = (right + left) // 2
           if nums[mid] < target:
              right = mid - 1
           elif num[mid] > target:
              left = mid + 1
            else:
               return mid
                      
              
```
## <a name="10">äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ¨¡ç‰ˆ(é€’å½’)</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
def binarySearch(self, nums: List[int], target: int) -> int:
    return self.binarySearchHelper(nums,target,0,n - 1,(n - 1) // 2)
    
    
def binarySearchHelper(self, nums: List[int], target: int,left: int, right: int, mid: int) -> int:   
     // recurison terminal
     if nums[mid] == target:
         retrun mid
    
    // process current logic
    mid = (left + right) // 2
    if nums[mid] < target
        right = mid - 1
    else nums[mid] > target
        left = mid + 1    
    // dill down
    self.binarySearchHelper(nums,target,left,right,mid)
    // restore status 
      
```

##é¢˜å‹ä¸€ï¼šæ’åˆ—ã€ç»„åˆã€å­é›†ç›¸å…³é—®é¢˜
æç¤ºï¼šè¿™éƒ¨åˆ†ç»ƒä¹ å¯ä»¥å¸®åŠ©æˆ‘ä»¬ç†Ÿæ‚‰ã€Œå›æº¯ç®—æ³•ã€çš„ä¸€äº›æ¦‚å¿µå’Œé€šç”¨çš„è§£é¢˜æ€è·¯ã€‚è§£é¢˜çš„æ­¥éª¤æ˜¯ï¼šå…ˆç”»å›¾ï¼Œå†ç¼–ç ã€‚å»æ€è€ƒå¯ä»¥å‰ªæçš„æ¡ä»¶ï¼Œ ä¸ºä»€ä¹ˆæœ‰çš„æ—¶å€™ç”¨ used æ•°ç»„ï¼Œæœ‰çš„æ—¶å€™è®¾ç½®æœç´¢èµ·ç‚¹ begin å˜é‡ï¼Œç†è§£çŠ¶æ€å˜é‡è®¾è®¡çš„æƒ³æ³•ã€‚

46. å…¨æ’åˆ—ï¼ˆä¸­ç­‰ï¼‰
47. å…¨æ’åˆ— IIï¼ˆä¸­ç­‰ï¼‰ï¼šæ€è€ƒä¸ºä»€ä¹ˆé€ æˆäº†é‡å¤ï¼Œå¦‚ä½•åœ¨æœç´¢ä¹‹å‰å°±åˆ¤æ–­è¿™ä¸€æ”¯ä¼šäº§ç”Ÿé‡å¤ï¼›
39. ç»„åˆæ€»å’Œï¼ˆä¸­ç­‰ï¼‰
40. ç»„åˆæ€»å’Œ IIï¼ˆä¸­ç­‰ï¼‰
77. ç»„åˆï¼ˆä¸­ç­‰ï¼‰
78. å­é›†ï¼ˆä¸­ç­‰ï¼‰
90. å­é›† IIï¼ˆä¸­ç­‰ï¼‰ï¼šå‰ªææŠ€å·§åŒ 47 é¢˜ã€39 é¢˜ã€40 é¢˜ï¼›
60. ç¬¬ k ä¸ªæ’åˆ—ï¼ˆä¸­ç­‰ï¼‰ï¼šåˆ©ç”¨äº†å‰ªæçš„æ€æƒ³ï¼Œå‡å»äº†å¤§é‡æå¶ï¼Œç›´æ¥æ¥åˆ°éœ€è¦çš„å¶å­ç»“ç‚¹ï¼›
93. å¤åŸ IP åœ°å€ï¼ˆä¸­ç­‰ï¼‰
## <a name="11">é¢˜å‹äºŒï¼šFlood Fill</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
æç¤ºï¼šFlood æ˜¯ã€Œæ´ªæ°´ã€çš„æ„æ€ï¼ŒFlood Fill ç›´è¯‘æ˜¯ã€Œæ³›æ´ªå¡«å……ã€çš„æ„æ€ï¼Œä½“ç°äº†æ´ªæ°´èƒ½å¤Ÿä»ä¸€ç‚¹å¼€å§‹ï¼Œè¿…é€Ÿå¡«æ»¡å½“å‰ä½ç½®é™„è¿‘çš„åœ°åŠ¿ä½çš„åŒºåŸŸã€‚ç±»ä¼¼çš„åº”ç”¨è¿˜æœ‰ï¼šPS è½¯ä»¶ä¸­çš„ã€Œç‚¹ä¸€ä¸‹æŠŠè¿™ä¸€ç‰‡åŒºåŸŸçš„é¢œè‰²éƒ½æ›¿æ¢æ‰ã€ï¼Œæ‰«é›·æ¸¸æˆã€Œç‚¹ä¸€ä¸‹æ‰“å¼€ä¸€å¤§ç‰‡æ²¡æœ‰é›·çš„åŒºåŸŸã€ã€‚

ä¸‹é¢è¿™å‡ ä¸ªé—®é¢˜ï¼Œæ€æƒ³ä¸éš¾ï¼Œä½†æ˜¯åˆå­¦çš„æ—¶å€™ä»£ç å¾ˆä¸å®¹æ˜“å†™å¯¹ï¼Œå¹¶ä¸”ä¹Ÿå¾ˆéš¾è°ƒè¯•ã€‚æˆ‘ä»¬çš„å»ºè®®æ˜¯å¤šå†™å‡ éï¼Œå¿˜è®°äº†å°±å†å†™ä¸€æ¬¡ï¼Œå‚è€ƒè§„èŒƒçš„ç¼–å†™å®ç°ï¼ˆè®¾ç½® visited æ•°ç»„ï¼Œè®¾ç½®æ–¹å‘æ•°ç»„ï¼ŒæŠ½å–ç§æœ‰æ–¹æ³•ï¼‰ï¼ŒæŠŠä»£ç å†™å¯¹ã€‚

733. å›¾åƒæ¸²æŸ“ï¼ˆFlood Fillï¼Œä¸­ç­‰ï¼‰
200. å²›å±¿æ•°é‡ï¼ˆä¸­ç­‰ï¼‰
130. è¢«å›´ç»•çš„åŒºåŸŸï¼ˆä¸­ç­‰ï¼‰
79. å•è¯æœç´¢ï¼ˆä¸­ç­‰ï¼‰
è¯´æ˜ï¼šä»¥ä¸Šé—®é¢˜éƒ½ä¸å»ºè®®ä¿®æ”¹è¾“å…¥æ•°æ®ï¼Œè®¾ç½® visited æ•°ç»„æ˜¯æ ‡å‡†çš„åšæ³•ã€‚å¯èƒ½ä¼šé‡åˆ°å‚æ•°å¾ˆå¤šï¼Œæ˜¯ä¸æ˜¯éƒ½å¯ä»¥å†™æˆæˆå‘˜å˜é‡çš„é—®é¢˜ï¼Œé¢è¯•ä¸­æ‹¿ä¸å‡†çš„è®°å¾—é—®ä¸€ä¸‹é¢è¯•å®˜

## <a name="12">é¢˜å‹ä¸‰ï¼šå­—ç¬¦ä¸²ä¸­çš„å›æº¯é—®é¢˜</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
æç¤ºï¼šå­—ç¬¦ä¸²çš„é—®é¢˜çš„ç‰¹æ®Šä¹‹å¤„åœ¨äºï¼Œå­—ç¬¦ä¸²çš„æ‹¼æ¥ç”Ÿæˆæ–°å¯¹è±¡ï¼Œå› æ­¤åœ¨è¿™ä¸€ç±»é—®é¢˜ä¸Šæ²¡æœ‰æ˜¾ç¤ºã€Œå›æº¯ã€çš„è¿‡ç¨‹ï¼Œä½†æ˜¯å¦‚æœä½¿ç”¨ StringBuilder æ‹¼æ¥å­—ç¬¦ä¸²å°±å¦å½“åˆ«è®ºã€‚
åœ¨è¿™é‡ŒæŠŠå®ƒä»¬å•ç‹¬ä½œä¸ºä¸€ä¸ªé¢˜å‹ï¼Œæ˜¯å¸Œæœ›æœ‹å‹ä»¬èƒ½å¤Ÿæ³¨æ„åˆ°è¿™ä¸ªéå¸¸ç»†èŠ‚çš„åœ°æ–¹ã€‚

1. ç”µè¯å·ç çš„å­—æ¯ç»„åˆï¼ˆä¸­ç­‰ï¼‰ï¼Œé¢˜è§£ï¼›
2. å­—æ¯å¤§å°å†™å…¨æ’åˆ—ï¼ˆä¸­ç­‰ï¼‰ï¼›
3. æ‹¬å·ç”Ÿæˆï¼ˆä¸­ç­‰ï¼‰ ï¼šè¿™é“é¢˜å¹¿åº¦ä¼˜å…ˆéå†ä¹Ÿå¾ˆå¥½å†™ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªé—®é¢˜ç†è§£ä¸€ä¸‹ä¸ºä»€ä¹ˆå›æº¯ç®—æ³•éƒ½æ˜¯æ·±åº¦ä¼˜å…ˆéå†ï¼Œå¹¶ä¸”éƒ½ç”¨é€’å½’æ¥å†™ã€‚

## <a name="13">é¢˜å‹å››ï¼šæ¸¸æˆé—®é¢˜</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
å›æº¯ç®—æ³•æ˜¯æ—©æœŸç®€å•çš„äººå·¥æ™ºèƒ½ï¼Œæœ‰äº›æ•™ç¨‹æŠŠå›æº¯å«åšæš´åŠ›æœç´¢ï¼Œä½†å›æº¯æ²¡æœ‰é‚£ä¹ˆæš´åŠ›ï¼Œå›æº¯æ˜¯æœ‰æ–¹å‘åœ°æœç´¢ã€‚ã€ŒåŠ›æ‰£ã€ä¸Šæœ‰ä¸€äº›ç®€å•çš„æ¸¸æˆç±»é—®é¢˜ï¼Œè§£å†³å®ƒä»¬æœ‰ä¸€å®šçš„éš¾åº¦ï¼Œå¤§å®¶å¯ä»¥å°è¯•ä¸€ä¸‹ã€‚

51. N çš‡åï¼ˆå›°éš¾ï¼‰ï¼šå…¶å®å°±æ˜¯å…¨æ’åˆ—é—®é¢˜ï¼Œæ³¨æ„è®¾è®¡æ¸…æ¥šçŠ¶æ€å˜é‡ï¼Œåœ¨éå†çš„æ—¶å€™éœ€è¦è®°ä½ä¸€äº›ä¿¡æ¯ï¼Œç©ºé—´æ¢æ—¶é—´ï¼›
37. è§£æ•°ç‹¬ï¼ˆå›°éš¾ï¼‰ï¼šæ€è·¯åŒã€ŒN çš‡åé—®é¢˜ã€ï¼›
488. ç¥–ç›æ¸¸æˆï¼ˆå›°éš¾ï¼‰
529. æ‰«é›·æ¸¸æˆï¼ˆå›°éš¾ï¼‰



#### <a name="14">ä»£ç </a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
|é¢˜ç›®|å›°éš¾ç¨‹åº¦|å®Œæˆæ¬¡æ•°|
|--:|--:|--:|
|[102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)|1|1|
|[33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)|1|1|
|[22. æ‹¬å·ç”Ÿæˆ](https://leetcode-cn.com/problems/generate-parentheses/)|1|1|
|[46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)|1|1|
|[47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/)|1|1|

#### <a name="15">102. äºŒå‰æ ‘çš„å±‚åºéå†</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
[102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
```
class TreeNode:
    def __init__(self, x:int):
        self.val = x;
        self.left = None
        self.right = None

from typing import List
import collections
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        level = []
        queue = collections.deque()
        queue.append(root)
        dummy = TreeNode(-1)
        queue.append(dummy)

        while len(queue) != 0:
            node = queue.popleft()
            if node == dummy:
                res.append(level)
                level = []
                if len(queue) != 0:
                    queue.append(dummy)
            else:
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return res

      å±‚åºéå†
     def levelOrder(self, root: TreeNode) -> List[List[int]]:
    
         res = []
         self.levelOrderHelper(root,0,res)
         return res
    
     def levelOrderHelper(self, node: TreeNode, level: int, res: List[int]):
         if len(res) == level:
             res.append([])
         res[level].append(node.val)
    
         if node.left:
             self.levelOrderHelper(node.left,level + 1,res)
         if node.right:
             self.levelOrderHelper(node.right, level + 1, res)

     å‰ä¸­åºåˆ›å»ºäºŒå‰æ ‘
    def buildTree(self, preorder:List[int], inorder:List[int]) -> TreeNode:
        if len(preorder) == 0:
            return None

        if len(preorder) != len(inorder):
            return None

        n = len(preorder)

        dict = {}
        for i in range(n):
            dict[inorder[i]] = i
        return self.buildTreeHelper(preorder,0,n - 1, 0, n - 1,dict)

     åˆ›å»ºäºŒå‰æ ‘å¸®åŠ©
    def buildTreeHelper(self,preorder:List[int], pre_left: int, pre_right: int, in_left: int, in_right: int, dict: {}) -> TreeNode:

        if pre_left > pre_right or in_left > in_right:
            return None

        rootValue = preorder[pre_left]
        index_root = dict[rootValue]
        root = TreeNode(rootValue)

        root.left = self.buildTreeHelper(preorder,pre_left + 1,index_root - in_left + pre_left, in_left, index_root - 1,dict)
        root.right = self.buildTreeHelper(preorder, index_root - in_left + pre_left + 1, pre_right, index_root + 1, in_right,
                                         dict)
        return root

a = Solution()
root = a.buildTree([3,9,20,15,7],[9,3,15,20,7])
print(a.levelOrder(root))


```
####### äºŒå‰æ ‘å±‚åºéå†çš„æ„Ÿæƒ³
```

    
```

#### <a name="16">33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
[33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
```
from typing import List
class Solution:
ç¬¬ä¸€ç§æ–¹å¼ï¼š
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)
        left, right = 0, n - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            if target >= nums[0]:
                if nums[mid] < nums[0]:
                    nums[mid] = float("inf")
            else:
                if nums[mid] >= nums[0]:
                    nums[mid] = float("-inf")

            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
                
  ç¬¬äºŒç§æ–¹å¼
  def search(self, nums: List[int], target: int) -> int:
        n = len(nums)
        if n == 0:
            return  -1
        left, right = 0, n - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[left]:
                if target >= nums[left] and target <= nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if target >= nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1              

```
##### <a name="17"> æœç´¢æ—‹è½¬æ’åºæ•°ç»„çš„æ„Ÿæƒ³</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
ç¬¬ä¸€ç§æ–¹å¼ï¼š
    
ç¬¬äºŒç§æ–¹å¼
    
  

```
##### <a name="18">22. æ‹¬å·ç”Ÿæˆ</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
[22. æ‹¬å·ç”Ÿæˆ](https://leetcode-cn.com/problems/generate-parentheses/)
```
    æ·±åº¦ä¼˜å…ˆéå†
    class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        self.dfs(0,0,n,"",res)
        return res

    def dfs(self, left:int, right:int, n:int, s:str, res:List[str]):

         recusion termimal
        if left == n and right == n:
            res.append(s)

         process current logic

         dill down
        if left < n:
            self.dfs(left + 1, right, n, s + "(", res)

        if right < left and right < n:
            self.dfs(left, right + 1, n, s + ")", res)

         restore

     å¹¿åº¦ä¼˜å…ˆéå† ï¼ˆæ²¡æˆåŠŸï¼‰
         def bfs(self, n:int, res:List[str]) -> List[str]:
        root = ListNode("",n,n)
        queue = collections.deque()
        queue.append(root)
        while len(queue) != 0:

            node = queue.popleft()
            if node.left == 0 and node.right == 0:
                res.append(node.s)

            if node.left > 0:
                listNode = ListNode(node.s + "(",node.left - 1,node.right)
                queue.append(listNode)

            if node.right > node.left and node.right > 0:
                listNode = ListNode(node.s + ")",node.left,node.right - 1)
                queue.append(listNode)
     
```
#####46. å…¨æ’åˆ—
æ—¶é—´å¤æ‚åº¦ä¸º o(n * n!)
[46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)
```
from typing import List
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if n <= 0:
            return []
        used = [False] * n
        res = []
        path = []
        self.dfs(nums, n,0,used,res,path)
        return res

    def dfs(self, nums:List[int], n:int, depth:int, used:List[bool],res:List[List[int]],path:List[int]):
        if n == depth:
            res.append(path.copy())
            return res
        for i in range(n):
            if used[i] == False:
                path.append(nums[i])
                used[i] = True
                self.dfs(nums,n,depth + 1,used,res,path)
                used[i] = False
                path.pop()
a = Solution()
print(a.permute([1,2,3]))
```
###### <a name="19">å…¨æ’åˆ—æ„Ÿæƒ³</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
æ³¨æ„ï¼šæœ€ç»ˆçš„æ‰§è¡Œæ–¹å¼è¿˜æ˜¯é€’å½’ï¼Œè„‘è¡¥é€’å½’çš„ç”»é¢ï¼Œä¸€å±‚ä¸€å±‚å¾€ä¸‹èµ°ï¼Œç›´åˆ°ç»™ä½ ä¸€ä¸ªä¿¡å· returnï¼Œå°±å¼€å§‹ä¸€å±‚ä¸€å±‚å¾€ä¸Šè¿”å›ï¼Œæ¯å±‚è¿”å›éƒ½ä¼šæ‰§è¡Œå®Œæ•´ä¸ªå‡½æ•°é¢˜
å…¶å®é€’å½’çš„è¿‡ç¨‹è·Ÿä¸Šä¸€ä¸ªæ‰§è¡Œæ–¹æ³•æ— å…³ï¼Œæ˜¯å¼€è¾Ÿäº†ä¸€ä¸ªæ–°çš„æ ˆç©ºé—´ï¼Œä¸€å±‚é€’å½’ä¸€ä¸ªæ–°çš„æ ˆç©ºé—´ã€‚åªæœ‰æœ€åçš„æ ˆç©ºé—´è°ƒç”¨ç»“æŸï¼Œæ‰ä¼šä¸€å±‚ä¸€å±‚è¿”å›ğŸ˜„
```
##### <a name="20">47. å…¨æ’åˆ— II</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
[47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/)
```
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if n <= 0:
            return []
        used = [False] * n
        path = []
        res = []
        nums.sort() // æ’åº
        self.dfs(nums, n, 0, res, used, path)
        return res

    def dfs(self, nums: List[int], n:int, depth:int, res:List[int], used:List[bool], path:List[int]):
        if depth == n:
            res.append(path.copy())
        for i in range(n):
            if used[i] == True:
                continue
            if (i > 0) and (nums[i] == nums[i - 1]) and (not used[i - 1]) : // æ­¤å¤„ä¸€å®šæ˜¯ used[i - 1],ä»£è¡¨å‰ä¸€ä¸ªå…ƒç´ å·²ç»è¢«ä½¿ç”¨è¿‡
                continue
            path.append(nums[i])
            used[i] = True
            self.dfs(nums, n, depth + 1, res, used, path)
            used[i] = False
            path.pop()         
```
###### <a name="21">å…¨æ’åˆ— IIæ„Ÿæƒ³</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
æ³¨æ„ï¼š
å‰ªæå‰ªå»çš„æ˜¯ï¼šè·Ÿå‰ä¸€ä¸ªæç‚¹ç›¸åŒï¼Œå¹¶ä¸”å‰ä¸€ä¸ªç»“ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œæ­¤æ—¶è¿™ä¸ªç»“ç‚¹å°±ä¸å†è®¿é—®ï¼Œå› ä¸ºä¼šè·Ÿä¹‹å‰çš„ç»“ç‚¹äº§ç”Ÿçš„å¶å­é‡å¤
```
##### <a name="22">77. ç»„åˆ</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        if n <= 0 or k > n:
            return []
        res = []
        path = []
        self.dfs(n, k, 0, res, path, 1)
        return res

    def dfs(self, n:int, k:int, depth:int, res:{}, path:List[int],begin:int):
        if depth == k:
            res.append(path.copy())
            return
        for i in range(begin,n + 1):
            path.append(i)
            self.dfs(n, k, depth + 1, res, path, i + 1)
            path.pop()
```
###### <a name="23">ç»„åˆæ„Ÿæƒ³</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
```
æ³¨æ„ï¼šæ­¤å¤„ä¸ä½¿ç”¨used[bool]æ˜¯å› ä¸ºbeginå·²ç»æ’é™¤äº†é‡å¤è®¿é—®çš„å¯èƒ½

```

##### <a name="24">560. å’Œä¸ºKçš„å­æ•°ç»„</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
[560. å’Œä¸ºKçš„å­æ•°ç»„](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
```
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = 0
        for i in range(len(nums)):
            sum = 0
            for j in range(i , -1, -1 ):
                sum += nums[j]
                if sum == k:
                    count += 1
        return count 
        
 def subarraySum(self, nums: List[int], k: int) -> int:

        pre = 0
        dict = {pre:1}
        count = 0
        for i in range(len(nums)):
            pre += nums[i]
            target = pre - k
            if target in dict.keys():
                count += dict[target]
                
            if pre in dict.keys():
                dict[pre] = dict[pre] + 1
            else:
                dict[pre] = 1
        return count

```


